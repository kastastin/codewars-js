// <-- Stone bridge primes -->

/*
  A special type of prime is generated by the formula p = 2^m * 3^n + 1 where m and n can be any non-negative integer.

  The first 5 of these primes are 2, 3, 5, 7, 13, and are generated as follows:

  2 = 2^0 * 3^0 + 1
  3 = 2^1 * 3^0 + 1
  5 = 2^2 * 3^0 + 1
  7 = 2^1 * 3^1 + 1
  13 = 2^2 * 3^1 + 1
  ..and so on

  You will be given a range and your task is to return the number of primes that have this property. For example, solve(0,15) = 5, because there are only 5 such primes >= 0 and < 15; they are 2,3,5,7,13. The upper limit of the tests will not exceed 1,500,000.
*/

// <-- My Solution -->
function solve(x, y) {
  const isPrime = Array(y).fill(true, 2);

  for (let i = 2; i * i <= y; i++) {
    if (isPrime[i]) for (let j = i + i; j < y; j += i) isPrime[j] = false;
  }

  let result = 0;
  const limit = Math.floor(Math.log2(y - 2));

  for (let i = 0; i <= limit; i++) {
    for (let j = 0; true; j++) {
      const current = 2 ** i * 3 ** j + 1;

      if (current >= y) break;

      if (current >= x && isPrime[current]) result++;
    }
  }

  return result;
}

// <-- Best Solution -->
const solve = (
  x,
  y,
  found = new Set(),
  maxN = Math.ceil(Math.log(y - 1) / Math.log(3)),
) => {
  for (let n = 0; n < maxN; n++) {
    const pow3n = 3 ** n;
    const lowRatio = Math.max((x - 1) / pow3n, 1);
    const mStart = Math.ceil(Math.log(lowRatio) / Math.log(2));
    const mEnd = Math.ceil(Math.log((y - 1) / pow3n) / Math.log(2));

    for (let m = mStart; m < mEnd; m++) {
      const candidate = 2 ** m * pow3n + 1;

      if (candidate < x || candidate >= y) continue;

      let isPrime = true;
      let limit = Math.floor(Math.sqrt(candidate));

      for (let d = 2; d <= limit; d++) {
        if (candidate % d === 0) {
          isPrime = false;
          break;
        }
      }

      if (isPrime) found.add(candidate);
    }
  }

  return found.size;
};
